<html>
<head>
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

    <!-- Optional theme -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous">

    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>

</head>
<body>
    <div class="container">

        <h1>commandparser <small>UNIX-style command line parsing</h1>
        <!-- FILE NAME AND TAG LINE GOES HERE -->

        <hr>

        <div class="row">
            <div class="col-md-4">

                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Contents</h3>
                    </div>
                    <div class="panel-body">

<ul>
<li>
<a href="#toc_0">Usage</a>
<ul>
<li>
<a href="#toc_1">Setting up the parser</a>
<ul>
<li>
<a href="#toc_2">Setting the description</a>
</li>
<li>
<a href="#toc_3">Adding a command</a>
</li>
<li>
<a href="#toc_4">Adding another command</a>
</li>
<li>
<a href="#toc_5">Starting up</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">Processing arguments</a>
</li>
<li>
<a href="#toc_7">Functions</a>
<ul>
<li>
<a href="#toc_8">Start</a>
</li>
<li>
<a href="#toc_9">Process</a>
</li>
<li>
<a href="#toc_10">AddCommand</a>
</li>
<li>
<a href="#toc_11">AddOption</a>
</li>
<li>
<a href="#toc_12">AddPositionalArgument</a>
</li>
<li>
<a href="#toc_13">PositionalArgument</a>
</li>
<li>
<a href="#toc_14">IsCommand</a>
</li>
<li>
<a href="#toc_15">IsOption</a>
</li>
<li>
<a href="#toc_16">IsSet</a>
</li>
<li>
<a href="#toc_17">Value</a>
</li>
<li>
<a href="#toc_18">SetDescription</a>
</li>
<li>
<a href="#toc_19">ErrorString</a>
</li>
<li>
<a href="#toc_20">Usage</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
                        <!-- TABLE OF CONTENTS GOES HERE -->

                    </div>
                </div>

            </div>
            <div class="col-md-8">
<pre><code>OBJ
    commandparser : "commandparser"</code></pre>

<h2>Description</h2>

<p>This object defines a rich command line parser for Spin terminals.</p>

<p>Some key features:</p>

<ul>
<li><p>Automatically generates command line help.</p></li>
<li><p>Supports options and one positional argument.</p></li>
<li><p>Supports multiple commands.</p></li>
<li><p>Uses only the <code>string</code> library so you can plug it into any output driver you want.</p></li>
</ul>

<h1 id="toc_0">Usage</h1>

<p>As with any thing else, we can define a string in place or in a DAT block elsewhere.
In this case, however, it is a good idea to define them in a DAT block because we will
refer to the strings by name frequently, and this way it is less wasteful.</p>

<h2 id="toc_1">Setting up the parser</h2>

<p>So let&#39;s start by writing out all our descriptions of the commands we want to use.</p>

<pre><code>DAT
    data_description    byte    &quot;This shell enables an interface to a live&quot;
                        byte    &quot;Propeller for debugging.&quot;,0

    cmd_help            byte    &quot;help&quot;,0

    cmd_hex             byte    &quot;hex&quot;,0
    cmd_hex_desc        byte    &quot;output hex to terminal&quot;,0

    cmd_info            byte    &quot;info&quot;,0
    cmd_info_desc       byte    &quot;print information about the running application&quot;,0

    opt_b               byte    &quot;-b&quot;,0
    opt_b_desc          byte    &quot;Enable some feature&quot;,0

    opt_c               byte    &quot;-c&quot;,0
    opt_c_desc          byte    &quot;And cool&quot;,0

    opt_d               byte    &quot;-d&quot;,0
    opt_d_desc          byte    &quot;Turn this on!&quot;,0

    pos_file            byte    &quot;FILE&quot;,0
    pos_file_desc       byte    &quot;The file on which to operate&quot;,0
</code></pre>

<h3 id="toc_2">Setting the description</h3>

<p>The description gives people a general overview of what this interface is for. It is the
first thing displayed when <code>Usage</code> is called.</p>

<pre><code>commandparser.SetDescription(@data_description)
</code></pre>

<h3 id="toc_3">Adding a command</h3>

<p>Let&#39;s add our first command, <code>hex</code>. We store the return value from <code>AddCommand</code> in a variable
because we will need it to add options to it.</p>

<p>hex := commandparser.AddCommand(@cmd<em>hex, @cmd</em>hex_desc)</p>

<p>Now let&#39;s add the options.</p>

<p>commandparser.AddOption (hex, @opt<em>b, @opt</em>b<em>desc, true)
commandparser.AddOption (hex, @opt</em>c, @opt<em>c</em>desc, true)
commandparser.AddOption (hex, @opt<em>d, @opt</em>d_desc, false)</p>

<p>Now let&#39;s add a positional argument. </p>

<p>commandparser.AddPositionalArgument (hex, @pos<em>file, @pos</em>file_desc)</p>

<h3 id="toc_4">Adding another command</h3>

<p>Now that we&#39;ve added <code>hex</code>, let&#39;s add a second command called <code>info</code>.</p>

<pre><code>commandparser.AddCommand(@cmd_info, @cmd_info_desc)
</code></pre>

<p>By default, this library allows a maximum of 5 commands, 5 options, and 10 arguments.
This can be easily change by updating the constants.</p>

<h3 id="toc_5">Starting up</h3>

<p>The only thing left to do before we can start parsing arguments is to start the parser.
This performs all the remaining setup left.</p>

<pre><code>commandparser.Start(@line, MAX_LINE)
</code></pre>

<p>@line is a pointer to a string that will contain the workspace for the command line parser.
It needs to be long enough to fit all of the arguments, which will depend on your needs.</p>

<p>Here is a good example definition:</p>

<pre><code>CON
    MAX_LINE = 40
VAR
    byte    line[MAX_LINE]
</code></pre>

<h2 id="toc_6">Processing arguments</h2>

<h2 id="toc_7">Functions</h2>

<h3 id="toc_8">Start</h3>

<p>Initialize the command line parser. You will need provide a string and
corresponding size of which you want the parser to be able to handle.</p>

<h3 id="toc_9">Process</h3>

<p>Process all command line tokens inside of the string.</p>

<p>This command should be run once every time ths argument string changes.</p>

<h3 id="toc_10">AddCommand</h3>

<p>Add a new command to the parser, with the name <code>name</code> and
a brief description called <code>description</code>.</p>

<p>This parser supports multiple commands, with different options
and positional arguments for each command.</p>

<h3 id="toc_11">AddOption</h3>

<p>Add an option to an existing command.</p>

<ul>
<li><p><code>name</code> - the name of the new option. Must start with <code>-</code>.
For example, <code>-b</code> or <code>--new</code>.</p></li>
<li><p><code>description</code> - a description of the new option for the
help printer. No text wrapping is performed so try to keep
descriptions short.</p></li>
<li><p><code>hasvalue</code> - if true, the command line parser will look for
a parameter following this option in the list of arguments.
For example, <code>--digit 23423</code>, <code>-b hello</code>.</p></li>
</ul>

<p>This command line does not support quotation marks, so parameters
should be single word.</p>

<p>This function does nothing if the command is not
already defined.</p>

<h3 id="toc_12">AddPositionalArgument</h3>

<p>Add a positional argument to the command line parser.</p>

<p>These are arguments that are not associated with any option.
For example, if you had the following list of arguments:</p>

<pre><code>hex -b 115200 0x3234 -d on
</code></pre>

<p>The positional argument would be 0x3234.</p>

<p>This command line parser supports exactly one positional
argument per command.</p>

<h3 id="toc_13">PositionalArgument</h3>

<p>Return a pointer to the string containing the positional
argument.</p>

<h3 id="toc_14">IsCommand</h3>

<p>Return true if the command passed to the parser is equal
to <code>cmd</code>, otherwise false.</p>

<h3 id="toc_15">IsOption</h3>

<p>Return true if the argument at position <code>n</code> in the string
is an option, otherwise false.</p>

<h3 id="toc_16">IsSet</h3>

<p>Return true if the option <code>option</code> was passed on the
command line, otherwise false.</p>

<h3 id="toc_17">Value</h3>

<p>Return a pointer to the string containing the value of
the option <code>option</code>.</p>

<h3 id="toc_18">SetDescription</h3>

<p>Set a brief description for the command line parser and
what it does.</p>

<h3 id="toc_19">ErrorString</h3>

<p>Return a string describing the error that was thrown when
<code>Process</code> was called.</p>

<pre><code>if (i := commandparser.Process) &lt;&gt; commandparser#ERROR_NONE
    term.Str(commandparser.ErrorString(i))
</code></pre>

<h3 id="toc_20">Usage</h3>

<p>Print a formatted help of the current command line parser.</p>

<p><code>commandparser</code> automatically adds a <code>help</code> function to the
list of commands when a parser is created.</p>

<p><code>Usage</code> does one of two things depending on when it is called.</p>

<ul>
<li><p>If an invalid command has been passed to the parser, or <code>help</code>
is called without a positional argument, a list of commands
is printed.</p></li>
<li><p>If a valid command is passed but its parameters are invalid, 
or <code>help</code> passed with the name of a valid command, usage
for that command is printed.        </p></li>
</ul>

<p>&quot;</p>
                <!-- CONTENT GOES HERE -->

            </div>
        </div>
        <hr>

        <!-- FOOTER GOES HERE -->

        <p><small>Generated by PropellerIDE DocView</small></p>
    </div>
</body>
</html>
