<html>
<head>
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

    <!-- Optional theme -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous">

    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>

</head>
<body>
    <div class="container">

        <h1>commandparser <small>UNIX-style command line parsing for Spin</small></h1>
        <!-- FILE NAME AND TAG LINE GOES HERE -->

        <hr>

        <div class="row">
            <div class="col-md-4">

                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Contents</h3>
                    </div>
                    <div class="panel-body">

                        <!-- TABLE OF CONTENTS GOES HERE -->
<ul>
<li>
<a href="#toc_0">Usage</a>
<ul>
<li>
<a href="#toc_1">Setting up the parser</a>
</li>
<li>
<a href="#toc_2">Processing commands</a>
</li>
<li>
<a href="#toc_3">Processing options and positional arguments</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">Functions</a>
<ul>
<li>
<a href="#toc_5">Start</a>
</li>
<li>
<a href="#toc_6">Process</a>
</li>
<li>
<a href="#toc_7">AddCommand</a>
</li>
<li>
<a href="#toc_8">AddOption</a>
</li>
<li>
<a href="#toc_9">AddPositionalArgument</a>
</li>
<li>
<a href="#toc_10">PositionalArgument</a>
</li>
<li>
<a href="#toc_11">IsCommand</a>
</li>
<li>
<a href="#toc_12">IsOption</a>
</li>
<li>
<a href="#toc_13">IsSet</a>
</li>
<li>
<a href="#toc_14">Value</a>
</li>
<li>
<a href="#toc_15">SetDescription</a>
</li>
<li>
<a href="#toc_16">ErrorString</a>
</li>
<li>
<a href="#toc_17">Usage</a>
</li>
</ul>
</li>
</ul>

                    </div>
                </div>

            </div>
            <div class="col-md-8">

                <!-- CONTENT GOES HERE -->
<p>This object defines a rich command line parser for Spin terminals.</p>

<p>Some key features:</p>

<ul>
<li>  Automatically generates command line help.</li>
<li>  Supports options and one positional argument.</li>
<li>  Supports multiple commands.</li>
<li>  Uses only the <code>string</code> library so you can plug it into any output driver you want.</li>
</ul>

<p><code>commandparser</code> will generate your list of commands for you on demand.</p>

<pre><code>$ help
This shell enables an interface to a live Propeller for debugging.
commands:

hex         output contents of memory to terminal
info        print information about the running application
help        show help
</code></pre>

<p>It will also generate help text for individual commands.</p>

<pre><code>$ help hex
Usage: hex [OPTIONS]... ADDR

options:

    -l VAL      Lines to print (default 16, limit 64)

positional argument:

    ADDR        The starting address of the RAM to examine.
</code></pre>

<p>It generates specific errors when incorrect commands are typed.</p>

<pre><code>$ hex -l
ERROR: Option missing parameter
</code></pre>

<h2 id="toc_0">Usage</h2>

<p>As with any thing else, we can define a string in place or in a DAT block elsewhere.
In this case, however, it is a good idea to define them in a DAT block because we will
refer to the strings by name frequently, and this way it is less wasteful.</p>

<h3 id="toc_1">Setting up the parser</h3>

<p>So let&#39;s start by writing out all our descriptions of the commands we want to use.</p>

<pre><code>DAT
    data_description    byte    &quot;This shell enables an interface to a live&quot;
                        byte    &quot;Propeller for debugging.&quot;,0

    cmd_help            byte    &quot;help&quot;,0

    cmd_hex             byte    &quot;hex&quot;,0
    cmd_hex_desc        byte    &quot;output hex to terminal&quot;,0

    cmd_info            byte    &quot;info&quot;,0
    cmd_info_desc       byte    &quot;print information about the running application&quot;,0

    opt_b               byte    &quot;-b&quot;,0
    opt_b_desc          byte    &quot;Enable some feature&quot;,0

    opt_c               byte    &quot;-c&quot;,0
    opt_c_desc          byte    &quot;And cool&quot;,0

    opt_d               byte    &quot;-d&quot;,0
    opt_d_desc          byte    &quot;Turn this on!&quot;,0

    pos_file            byte    &quot;FILE&quot;,0
    pos_file_desc       byte    &quot;The file on which to operate&quot;,0
</code></pre>

<h4>Setting the description</h4>

<p>The description gives people a general overview of what this interface is for. It is the
first thing displayed when <code>Usage</code> is called.</p>

<pre><code>commandparser.SetDescription(@data_description)
</code></pre>

<h4>Adding a command</h4>

<p>Let&#39;s add our first command, <code>hex</code>. We store the return value from <code>AddCommand</code> in a variable
because we will need it to add options to it.</p>

<p>hex := commandparser.AddCommand(@cmd<em>hex, @cmd</em>hex_desc)</p>

<p>Now let&#39;s add the options.</p>

<p>commandparser.AddOption (hex, @opt<em>b, @opt</em>b<em>desc, true)
commandparser.AddOption (hex, @opt</em>c, @opt<em>c</em>desc, true)
commandparser.AddOption (hex, @opt<em>d, @opt</em>d_desc, false)</p>

<p>Now let&#39;s add a positional argument. </p>

<p>commandparser.AddPositionalArgument (hex, @pos<em>file, @pos</em>file_desc)</p>

<h4>Adding another command</h4>

<p>Now that we&#39;ve added <code>hex</code>, let&#39;s add a second command called <code>info</code>.</p>

<pre><code>commandparser.AddCommand(@cmd_info, @cmd_info_desc)
</code></pre>

<p>By default, this library allows a maximum of 5 commands, 5 options, and 10 arguments.
This can be easily change by updating the constants.</p>

<h4>Starting up</h4>

<p>The only thing left to do before we can start parsing arguments is to start the parser.
This performs the remaining setup.</p>

<pre><code>commandparser.Start(@line, MAX_LINE)
</code></pre>

<p>@line is a pointer to a string that will contain the workspace for the command line parser.
It needs to be long enough to fit all of the arguments, which will depend on your needs.</p>

<p>Here is a good example definition:</p>

<pre><code>CON
    MAX_LINE = 40
VAR
    byte    line[MAX_LINE]
</code></pre>

<h3 id="toc_2">Processing commands</h3>

<p>Processing arguments is straightforward. It is as simple as setting up some boilerplate code.</p>

<p>The first step is running <code>Process</code>, and checking to see if it returned any errors. If so,
we can get more information about what happened with <code>ErrorString</code> and remind the user how
to use the command line with <code>Usage</code>. The printout from <code>Usage</code> is context-sensitive and changes
depending on what the user was last doing.</p>

<pre><code>if (i := commandparser.Process) &lt;&gt; commandparser#ERROR_NONE
    term.Str (commandparser.ErrorString(i))
    term.Str (commandparser.Usage)
</code></pre>

<p>We can also explicitly print the help information if a command is received.</p>

<p>elseif commandparser.IsCommand (@cmd_help)
    term.Str (commandparser.Usage)</p>

<p>Here is where we start processing commands</p>

<pre><code>elseif commandparser.IsCommand (@cmd_hex)
    HexCommand

elseif commandparser.IsCommand (@cmd_info)
    InfoCommand
</code></pre>

<p>An <code>else</code> is not be needed as an error would have been received before it had a chance to get here.</p>

<h3 id="toc_3">Processing options and positional arguments</h3>

<p>Once the command is known, we can start processing the arguments for individual commands with the
following functions: <code>IsSet</code>, <code>Value</code>, and <code>PositionalArgument</code>.</p>

<ul>
<li>  <code>IsSet</code> returns true if an option was set, otherwise false.</li>
<li>  <code>Value</code> returns a pointer to the string containing the value of the option if available, or null.</li>
<li>  <code>PositionalArgument</code> returns a pointer to the string containing the positional argument, or null
if not available.</li>
</ul>

<p>And that&#39;s all. The parser is ready to use.    </p>

<h2 id="toc_4">Functions</h2>
<hr>

<h3 id="toc_5">Start</h3>

<p>Initialize the command line parser. You will need provide a string and
corresponding size of which you want the parser to be able to handle.</p>

<h3 id="toc_6">Process</h3>

<p>Process all command line tokens inside of the string.</p>

<p>This command should be run once every time ths argument string changes.</p>

<h3 id="toc_7">AddCommand</h3>

<p>Add a new command to the parser, with the name <code>name</code> and
a brief description called <code>description</code>.</p>

<p>This parser supports multiple commands, with different options
and positional arguments for each command.</p>

<h3 id="toc_8">AddOption</h3>

<p>Add an option to an existing command.</p>

<ul>
<li><p><code>name</code> - the name of the new option. Must start with <code>-</code>.
For example, <code>-b</code> or <code>--new</code>.</p></li>
<li><p><code>description</code> - a description of the new option for the
help printer. No text wrapping is performed so try to keep
descriptions short.</p></li>
<li><p><code>hasvalue</code> - if true, the command line parser will look for
a parameter following this option in the list of arguments.
For example, <code>--digit 23423</code>, <code>-b hello</code>.</p></li>
</ul>

<p>This command line does not support quotation marks, so parameters
should be single word.</p>

<p>This function does nothing if the command is not
already defined.</p>

<h3 id="toc_9">AddPositionalArgument</h3>

<p>Add a positional argument to the command line parser.</p>

<p>These are arguments that are not associated with any option.
For example, if you had the following list of arguments:</p>

<pre><code>hex -b 115200 0x3234 -d on
</code></pre>

<p>The positional argument would be 0x3234.</p>

<p>This command line parser supports exactly one positional
argument per command.</p>

<h3 id="toc_10">PositionalArgument</h3>

<p>Return a pointer to the string containing the positional
argument.</p>

<h3 id="toc_11">IsCommand</h3>

<p>Return true if the command passed to the parser is equal
to <code>cmd</code>, otherwise false.</p>

<h3 id="toc_12">IsOption</h3>

<p>Return true if the argument at position <code>n</code> in the string
is an option, otherwise false.</p>

<h3 id="toc_13">IsSet</h3>

<p>Return true if the option <code>option</code> was passed on the
command line, otherwise false.</p>

<h3 id="toc_14">Value</h3>

<p>Return a pointer to the string containing the value of
the option <code>option</code>.</p>

<h3 id="toc_15">SetDescription</h3>

<p>Set a brief description for the command line parser and
what it does.</p>

<h3 id="toc_16">ErrorString</h3>

<p>Return a string describing the error that was thrown when
<code>Process</code> was called.</p>

<pre><code>if (i := commandparser.Process) &lt;&gt; commandparser#ERROR_NONE
    term.Str(commandparser.ErrorString(i))
</code></pre>

<h3 id="toc_17">Usage</h3>

<p>Print a formatted help of the current command line parser.</p>

<p><code>commandparser</code> automatically adds a <code>help</code> function to the
list of commands when a parser is created.</p>

<p><code>Usage</code> does one of two things depending on when it is called.</p>

<ul>
<li><p>If an invalid command has been passed to the parser, or <code>help</code>
is called without a positional argument, a list of commands
is printed.</p></li>
<li><p>If a valid command is passed but its parameters are invalid, 
or <code>help</code> passed with the name of a valid command, usage
for that command is printed.        </p></li>
</ul>

            </div>
        </div>
        <hr>

        <!-- FOOTER GOES HERE -->

        <p><small>Generated by PropellerIDE DocView</small></p>
    </div>
</body>
</html>
